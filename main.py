import os
import logging
from logging.handlers import RotatingFileHandler
import re
import asyncio
import uuid
from functools import wraps

import paramiko
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ConversationHandler,
    MessageHandler,
    ContextTypes,
    filters,
)
from telegram.constants import ParseMode
from telegram.error import BadRequest

# --- –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ ---
load_dotenv()

# --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ---
BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_USER_ID = os.getenv("ADMIN_USER_ID")
SSH_HOST = os.getenv("SSH_HOST")
SSH_PORT = int(os.getenv("SSH_PORT", 22))
SSH_USER = os.getenv("SSH_USER")
SSH_KEY_PATH = os.getenv("SSH_KEY_PATH")
CPU_THRESHOLD = float(os.getenv("CPU_THRESHOLD", 90.0))
RAM_THRESHOLD = float(os.getenv("RAM_THRESHOLD", 90.0))
DISK_THRESHOLD = float(os.getenv("DISK_THRESHOLD", 95.0))


# --- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler ---
RESTART_SERVICE, KILL_PROCESS_PID = range(2)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ---
log_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler = RotatingFileHandler('bot.log', maxBytes=5*1024*1024, backupCount=5, encoding='utf-8')
file_handler.setFormatter(log_formatter)
console_handler = logging.StreamHandler()
console_handler.setFormatter(log_formatter)
logger = logging.getLogger()
logger.setLevel(logging.INFO)
if not logger.handlers:
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

# --- –î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ ---
def admin_only(func):
    @wraps(func)
    async def wrapped(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
        user_id = update.effective_user.id
        if str(user_id) != ADMIN_USER_ID:
            logger.warning(f"Unauthorized access denied for {user_id}.")
            if update.callback_query:
                await update.callback_query.answer("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.", show_alert=True)
            elif update.message:
                await update.message.reply_text("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω.")
            return
        return await func(update, context, *args, **kwargs)
    return wrapped

# --- SSH –∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ---
async def execute_ssh_command(command: str) -> str:
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        private_key = paramiko.RSAKey.from_private_key_file(SSH_KEY_PATH)
        await asyncio.to_thread(
            ssh.connect, SSH_HOST, port=SSH_PORT, username=SSH_USER, pkey=private_key, timeout=15
        )
        stdin, stdout, stderr = ssh.exec_command(command, timeout=30)
        output = stdout.read().decode('utf-8').strip()
        error = stderr.read().decode('utf-8').strip()
        ssh.close()
        if error:
            logger.error(f"SSH command error for '{command}': {error}")
            return f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã: {error}"
        return output
    except Exception as e:
        logger.error(f"SSH connection or command failed: {e}")
        return f"üö® –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É –∏–ª–∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É. –û—à–∏–±–∫–∞: {e}"

# --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
def get_main_menu_keyboard():
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üìä –î–∞—à–±–æ—Ä–¥", callback_data='dashboard_start'),
            InlineKeyboardButton("‚ÑπÔ∏è –°–≤–æ–¥–∫–∞", callback_data='get_summary'),
        ],
        [InlineKeyboardButton("‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", callback_data='open_management_menu')],
        [
            InlineKeyboardButton("üöÄ SpeedTest", callback_data='run_speedtest'),
            InlineKeyboardButton("üîå –°–µ—Ç—å", callback_data='get_network_info'),
        ],
    ])

def get_management_menu_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üîÑ –†–µ—Å—Ç–∞—Ä—Ç —Å–ª—É–∂–±—ã", callback_data='restart_service_prompt')],
        [InlineKeyboardButton("üìú –ü–æ–ª—É—á–∏—Ç—å –ª–æ–≥", callback_data='get_log_info')],
        [InlineKeyboardButton("üìà –¢–æ–ø –ø—Ä–æ—Ü–µ—Å—Å–æ–≤", callback_data='get_top_processes')],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data='main_menu')],
    ])

def get_top_processes_keyboard(back_target='open_management_menu'):
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üíÄ –ó–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å", callback_data='kill_process_prompt')],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data=back_target)],
    ])

def get_back_keyboard(target='main_menu'):
    return InlineKeyboardMarkup([[InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data=target)]])

# --- –û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ---
@admin_only
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    current_jobs = context.job_queue.get_jobs_by_name(str(update.effective_user.id))
    for job in current_jobs: job.schedule_removal()
    
    await update.message.reply_text(
        "üëã **–ë–æ—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–µ—Ä–≤–µ—Ä–∞**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=get_main_menu_keyboard(),
        parse_mode=ParseMode.MARKDOWN
    )

@admin_only
async def main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "üëã **–ë–æ—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–µ—Ä–≤–µ—Ä–∞**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=get_main_menu_keyboard(),
        parse_mode=ParseMode.MARKDOWN
    )

@admin_only
async def open_management_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "‚öôÔ∏è **–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è**",
        reply_markup=get_management_menu_keyboard(),
        parse_mode=ParseMode.MARKDOWN
    )

# --- –î–∞—à–±–æ—Ä–¥ ---
async def update_dashboard_job(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    try:
        ram_cmd = "free -b | awk 'NR==2{printf \"%.1f\", $3/$2*100}'"
        cpu_cmd = "uptime | awk -F'load average: ' '{print $2}'"
        disk_cmd = "df -h / | awk 'NR==2{print $5}'"
        
        ram_percent = float(await execute_ssh_command(ram_cmd))
        cpu_load = (await execute_ssh_command(cpu_cmd)).strip()
        disk_usage = (await execute_ssh_command(disk_cmd)).strip()

        ram_bar = f"[{'‚ñà' * int(ram_percent / 10) + '‚îÄ' * (10 - int(ram_percent / 10))}] {ram_percent:.1f}%"
        
        text = (
            f"üìä **–î–∞—à–±–æ—Ä–¥ (–æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫)**\n\n"
            f"üß† **RAM:** {ram_bar}\n"
            f"üíª **CPU Load:** `{cpu_load}`\n"
            f"üíæ **–î–∏—Å–∫ (–∫–æ—Ä–µ–Ω—å):** `{disk_usage}` –∑–∞–Ω—è—Ç–æ"
        )
        await context.bot.edit_message_text(
            chat_id=job.chat_id,
            message_id=job.data['message_id'],
            text=text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data='dashboard_stop')]]),
            parse_mode=ParseMode.MARKDOWN
        )
    except BadRequest as e:
        if "Message is not modified" in str(e): pass
        else:
            logger.error(f"Dashboard update error: {e}")
            job.schedule_removal()
    except Exception as e:
        logger.error(f"Dashboard job failed: {e}")
        job.schedule_removal()

@admin_only
async def dashboard_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    current_jobs = context.job_queue.get_jobs_by_name(str(query.from_user.id))
    for job in current_jobs: job.schedule_removal()
    message = await query.edit_message_text("‚è≥ –ó–∞–ø—É—Å–∫–∞—é –¥–∞—à–±–æ—Ä–¥...")
    context.job_queue.run_repeating(
        update_dashboard_job, interval=10, first=0.1,
        chat_id=query.from_user.id,
        data={'message_id': message.message_id},
        name=str(query.from_user.id)
    )

@admin_only
async def dashboard_stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    current_jobs = context.job_queue.get_jobs_by_name(str(query.from_user.id))
    for job in current_jobs:
        job.schedule_removal()
    await query.delete_message()

# --- –°–≤–æ–¥–∫–∞ –ø–æ —Å–µ—Ä–≤–µ—Ä—É (Neofetch) ---
@admin_only
async def get_server_summary(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("‚è≥ –°–æ–±–∏—Ä–∞—é —Å–≤–æ–¥–∫—É –ø–æ —Å–µ—Ä–≤–µ—Ä—É...")

    command = "cat /etc/os-release | grep PRETTY_NAME | cut -d'\"' -f2; " \
              "hostname; " \
              "uptime -p; " \
              "grep 'model name' /proc/cpuinfo | head -1 | cut -d':' -f2 | sed 's/^ *//'; " \
              "free -h | awk '/^Mem:/ {print $3\" / \"$2}'; " \
              "df -h / | awk 'NR==2 {print $3\" / \"$2\" (\"$5\")\"}'"
    output = await execute_ssh_command(command)
    
    try:
        os_name, host, uptime, cpu, ram, disk = output.split('\n')
        art = ["      .--.     ", "     |o_o |    ", "     |:_/ |    ", "    //   \ \   ", "   (|     | )  ", "  /'\_   _/`\  ", "  \___)=(___/  "]
        data = [f"OS:      {os_name}", f"Host:    {host}", f"Uptime:  {uptime}", f"CPU:     {cpu}", f"RAM:     {ram}", f"Disk:    {disk}", ""]
        result = [art[i] + data[i] for i in range(len(art))]
        formatted_output = "\n".join(result)
        
        await query.edit_message_text(f"‚ÑπÔ∏è **–°–≤–æ–¥–∫–∞ –ø–æ —Å–µ—Ä–≤–µ—Ä—É**\n\n<pre>{formatted_output}</pre>", reply_markup=get_back_keyboard(), parse_mode=ParseMode.HTML)
    except Exception as e:
        logger.error(f"Failed to create summary: {e}. Output: {output}")
        await query.edit_message_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–≤–æ–¥–∫—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.", reply_markup=get_back_keyboard())

# --- –î—Ä—É–≥–∏–µ –∫–æ–º–∞–Ω–¥—ã ---
@admin_only
async def get_network_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("‚è≥ –ü–æ–ª—É—á–∞—é —Å–µ—Ç–µ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é...")
    output = await execute_ssh_command("ss -tulnp")
    await query.edit_message_text(f"üîå **–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Ç–µ–≤—ã–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è**\n\n<pre>{output}</pre>", reply_markup=get_back_keyboard(), parse_mode=ParseMode.HTML)

@admin_only
async def run_speedtest(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("üöÄ –ó–∞–ø—É—Å–∫–∞—é SpeedTest... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –¥–æ –º–∏–Ω—É—Ç—ã.")
    output = await execute_ssh_command("speedtest-cli --simple")
    try:
        ping = re.search(r"Ping: ([\d.]+) ms", output).group(1)
        download = re.search(r"Download: ([\d.]+) Mbit/s", output).group(1)
        upload = re.search(r"Upload: ([\d.]+) Mbit/s", output).group(1)
        text = f"üåê **–†–µ–∑—É–ª—å—Ç–∞—Ç—ã SpeedTest**\n\n**Ping:** `{ping} ms`\n**Download:** `‚Üì {download} Mbit/s`\n**Upload:** `‚Üë {upload} Mbit/s`"
        await query.edit_message_text(text, reply_markup=get_back_keyboard(), parse_mode=ParseMode.MARKDOWN)
    except AttributeError:
        await query.edit_message_text(f"üåê **–†–µ–∑—É–ª—å—Ç–∞—Ç SpeedTest (raw)**\n\n<pre>{output}</pre>", reply_markup=get_back_keyboard(), parse_mode=ParseMode.HTML)

# --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏ ---
@admin_only
async def get_top_processes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("‚è≥ –ü–æ–ª—É—á–∞—é —Å–ø–∏—Å–æ–∫ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤...")
    command = "ps -eo pid,pcpu,pmem,comm --sort=-pcpu | head -n 11"
    output = await execute_ssh_command(command)
    await query.edit_message_text(f"üìà **–¢–æ–ø –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –ø–æ CPU**\n\n<pre>{output}</pre>", reply_markup=get_top_processes_keyboard(), parse_mode=ParseMode.HTML)

async def kill_process_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("üíÄ **–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞**\n\n–í–≤–µ–¥–∏—Ç–µ PID –ø—Ä–æ—Ü–µ—Å—Å–∞, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å.", reply_markup=get_back_keyboard('open_management_menu'))
    return KILL_PROCESS_PID

async def kill_process_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    pid = update.message.text
    if not pid.isdigit():
        await update.message.reply_text("–≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ PID. –í–≤–µ–¥–∏—Ç–µ —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã.", reply_markup=get_back_keyboard('open_management_menu'))
        return KILL_PROCESS_PID
    context.user_data['pid_to_kill'] = pid
    keyboard = InlineKeyboardMarkup([[InlineKeyboardButton(f"‚úÖ –î–∞, –∑–∞–≤–µ—Ä—à–∏—Ç—å PID {pid}", callback_data=f'kill_process_yes')], [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data='open_management_menu')]])
    await update.message.reply_text(f"–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –∑–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å —Å PID `{pid}`?", reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
    return ConversationHandler.END

async def kill_process_execute(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    pid = context.user_data.get('pid_to_kill')
    await query.answer()
    await query.edit_message_text(f"‚è≥ –ó–∞–≤–µ—Ä—à–∞—é –ø—Ä–æ—Ü–µ—Å—Å {pid}...")
    output = await execute_ssh_command(f"kill {pid} && echo 'OK'")
    text = f"‚úÖ –ü—Ä–æ—Ü–µ—Å—Å —Å PID `{pid}` —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω." if "OK" in output else f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å `{pid}`.\n<pre>{output}</pre>"
    await query.edit_message_text(text, reply_markup=get_back_keyboard('open_management_menu'), parse_mode=ParseMode.HTML)

# --- –õ–æ–≥–∏ –∏ –†–µ—Å—Ç–∞—Ä—Ç ---
@admin_only
async def get_log_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "üìú **–ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–≥–∞**\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/logs`, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª —Å –ª–æ–≥–∞–º–∏.\n\n"
        "**–§–æ—Ä–º–∞—Ç:**\n`/logs [–∫–æ–ª-–≤–æ —Å—Ç—Ä–æ–∫] [–ø—É—Ç—å –∫ —Ñ–∞–π–ª—É]`\n\n"
        "**–ü—Ä–∏–º–µ—Ä—ã:**\n`/logs 500 /var/log/nginx/access.log`\n"
        "`/logs /var/log/syslog` (–≤–µ—Ä–Ω–µ—Ç 200 —Å—Ç—Ä–æ–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)",
        reply_markup=get_back_keyboard('open_management_menu'),
        parse_mode=ParseMode.MARKDOWN
    )

@admin_only
async def view_logs_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    lines = 200
    log_path = ""

    if len(args) == 1:
        log_path = args[0]
    elif len(args) >= 2 and args[0].isdigit():
        lines = int(args[0])
        log_path = " ".join(args[1:])
    else:
        await update.message.reply_text(
            "‚ö†Ô∏è **–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã.**\n\n"
            "**–§–æ—Ä–º–∞—Ç:** `/logs [–∫–æ–ª-–≤–æ —Å—Ç—Ä–æ–∫] [–ø—É—Ç—å]`\n"
            "**–ü—Ä–∏–º–µ—Ä:** `/logs 500 /var/log/syslog`",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    msg = await update.message.reply_text(f"‚è≥ –°–æ–±–∏—Ä–∞—é –ø–æ—Å–ª–µ–¥–Ω–∏–µ {lines} —Å—Ç—Ä–æ–∫ –∏–∑ `{log_path}`...", parse_mode=ParseMode.MARKDOWN)
    output = await execute_ssh_command(f"tail -n {lines} {log_path}")

    if "–û—à–∏–±–∫–∞" in output or "No such file" in output or not output:
        await msg.edit_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ª–æ–≥.\n`{output}`", parse_mode=ParseMode.MARKDOWN)
        return
    
    temp_filename = ""
    try:
        temp_filename = f"{os.path.basename(log_path)}_{uuid.uuid4()}.log"
        with open(temp_filename, "w", encoding="utf-8") as f: f.write(output)
        with open(temp_filename, "rb") as f:
            await context.bot.send_document(
                chat_id=update.effective_chat.id,
                document=f,
                caption=f"üìã –í–æ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ {lines} —Å—Ç—Ä–æ–∫ –∏–∑ –ª–æ–≥–∞ `{log_path}`",
                parse_mode=ParseMode.MARKDOWN
            )
        await msg.delete()
    finally:
        if temp_filename and os.path.exists(temp_filename): os.remove(temp_filename)

async def restart_service_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("üîÑ **–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–ª—É–∂–±—ã**\n\n–í–≤–µ–¥–∏—Ç–µ –∏–º—è —Å–ª—É–∂–±—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, `nginx`).", reply_markup=get_back_keyboard('open_management_menu'))
    return RESTART_SERVICE

async def restart_service_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    service_name = update.message.text.strip()
    context.user_data['service_to_restart'] = service_name
    keyboard = InlineKeyboardMarkup([[InlineKeyboardButton(f"‚úÖ –î–∞, –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å {service_name}", callback_data=f'restart_service_yes')], [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data='open_management_menu')]])
    await update.message.reply_text(f"–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–ª—É–∂–±—É `{service_name}`?", reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
    return ConversationHandler.END

async def restart_service_execute(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    service_name = context.user_data.get('service_to_restart')
    await query.answer()
    await query.edit_message_text(f"‚è≥ –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—é —Å–ª—É–∂–±—É `{service_name}`...", parse_mode=ParseMode.MARKDOWN)
    output = await execute_ssh_command(f"sudo systemctl restart {service_name} && echo 'OK'")
    text = f"‚úÖ –°–ª—É–∂–±–∞ `{service_name}` —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω–∞." if "OK" in output else f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–ª—É–∂–±—É `{service_name}`.\n<pre>{output}</pre>"
    await query.edit_message_text(text, reply_markup=get_back_keyboard('open_management_menu'), parse_mode=ParseMode.HTML)

# --- –§–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ (–ê–≤—Ç–æ–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥) ---
# –≠—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ –≤—ã–∑—ã–≤–∞—é—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é, –∞ —Ä–∞–±–æ—Ç–∞—é—Ç –≤ —Ñ–æ–Ω–µ —á–µ—Ä–µ–∑ job_queue
async def check_server_availability(context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ SSH."""
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        private_key = paramiko.RSAKey.from_private_key_file(SSH_KEY_PATH)
        await asyncio.to_thread(
             ssh.connect, SSH_HOST, port=SSH_PORT, username=SSH_USER, pkey=private_key, timeout=10
        )
        ssh.close()
        logger.info("Availability check: Server is UP.")
    except Exception as e:
        logger.error(f"Availability check: Server is DOWN. Error: {e}")
        await context.bot.send_message(chat_id=ADMIN_USER_ID, text=f"üö® –í–ù–ò–ú–ê–ù–ò–ï! –°–µ—Ä–≤–µ—Ä {SSH_HOST} –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω! –û—à–∏–±–∫–∞: {e}")

async def check_thresholds(context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ—Ä–æ–≥–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤."""
    try:
        cpu_cmd = "top -bn1 | grep 'Cpu(s)' | sed 's/.*, *\\([0-9.]*\\)%* id.*/\\1/' | awk '{print 100 - $1}'"
        ram_cmd = "free | grep Mem | awk '{print $3/$2 * 100.0}'"
        disk_cmd = "df / | tail -n 1 | awk '{print $5}' | sed 's/%//'"
        
        cpu_usage = float(await execute_ssh_command(cpu_cmd))
        if cpu_usage > CPU_THRESHOLD:
            await context.bot.send_message(chat_id=ADMIN_USER_ID, text=f"üìà –í–ù–ò–ú–ê–ù–ò–ï! –ù–∞–≥—Ä—É–∑–∫–∞ CPU –ø—Ä–µ–≤—ã—Å–∏–ª–∞ –ø–æ—Ä–æ–≥: {cpu_usage:.2f}% (–ü–æ—Ä–æ–≥: {CPU_THRESHOLD}%)")

        ram_usage = float(await execute_ssh_command(ram_cmd))
        if ram_usage > RAM_THRESHOLD:
            await context.bot.send_message(chat_id=ADMIN_USER_ID, text=f"üìà –í–ù–ò–ú–ê–ù–ò–ï! –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ RAM –ø—Ä–µ–≤—ã—Å–∏–ª–æ –ø–æ—Ä–æ–≥: {ram_usage:.2f}% (–ü–æ—Ä–æ–≥: {RAM_THRESHOLD}%)")

        disk_usage = float(await execute_ssh_command(disk_cmd))
        if disk_usage > DISK_THRESHOLD:
            await context.bot.send_message(chat_id=ADMIN_USER_ID, text=f"üìà –í–ù–ò–ú–ê–ù–ò–ï! –ú–µ—Å—Ç–æ –Ω–∞ –¥–∏—Å–∫–µ –ø—Ä–µ–≤—ã—Å–∏–ª–æ –ø–æ—Ä–æ–≥: {disk_usage:.2f}% (–ü–æ—Ä–æ–≥: {DISK_THRESHOLD}%)")
    except Exception as e:
        logger.error(f"Could not check thresholds. Error: {e}")


# --- –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è ---
def main():
    application = Application.builder().token(BOT_TOKEN).build()

    # --- Handlers ---
    conv_handlers = {
        "restart": ConversationHandler(entry_points=[CallbackQueryHandler(restart_service_prompt, '^restart_service_prompt$')], states={RESTART_SERVICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, restart_service_confirm)]}, fallbacks=[CallbackQueryHandler(open_management_menu, '^open_management_menu$')]),
        "kill": ConversationHandler(entry_points=[CallbackQueryHandler(kill_process_prompt, '^kill_process_prompt$')], states={KILL_PROCESS_PID: [MessageHandler(filters.TEXT & ~filters.COMMAND, kill_process_confirm)]}, fallbacks=[CallbackQueryHandler(open_management_menu, '^open_management_menu$')]),
    }
    callback_handlers = {
        '^main_menu$': main_menu,
        '^open_management_menu$': open_management_menu,
        '^dashboard_start$': dashboard_start,
        '^dashboard_stop$': dashboard_stop,
        '^get_summary$': get_server_summary,
        '^get_network_info$': get_network_info,
        '^run_speedtest$': run_speedtest,
        '^get_top_processes$': get_top_processes,
        '^get_log_info$': get_log_info,
        '^restart_service_yes$': restart_service_execute,
        '^kill_process_yes$': kill_process_execute,
    }
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("logs", view_logs_command))

    for pattern, handler in callback_handlers.items():
        application.add_handler(CallbackQueryHandler(handler, pattern=pattern))
    for handler in conv_handlers.values():
        application.add_handler(handler)

    # --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á ---
    job_queue = application.job_queue
    job_queue.run_repeating(check_server_availability, interval=120, first=15) 
    job_queue.run_repeating(check_thresholds, interval=600, first=30)

    logger.info("Bot started with new interactive UI and background monitoring...")
    application.run_polling()

if __name__ == "__main__":
    main()
